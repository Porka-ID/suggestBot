'use strict';

var v10 = require('discord-api-types/v10');

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var optionTypeToPrettyName = /* @__PURE__ */ new Map([
  [v10.ApplicationCommandOptionType.Subcommand, "subcommand"],
  [v10.ApplicationCommandOptionType.SubcommandGroup, "subcommand group"],
  [v10.ApplicationCommandOptionType.String, "string option"],
  [v10.ApplicationCommandOptionType.Integer, "integer option"],
  [v10.ApplicationCommandOptionType.Boolean, "boolean option"],
  [v10.ApplicationCommandOptionType.User, "user option"],
  [v10.ApplicationCommandOptionType.Channel, "channel option"],
  [v10.ApplicationCommandOptionType.Role, "role option"],
  [v10.ApplicationCommandOptionType.Mentionable, "mentionable option"],
  [v10.ApplicationCommandOptionType.Number, "number option"],
  [v10.ApplicationCommandOptionType.Attachment, "attachment option"]
]);
var contextMenuTypes = [v10.ApplicationCommandType.Message, v10.ApplicationCommandType.User];
var subcommandTypes = [v10.ApplicationCommandOptionType.SubcommandGroup, v10.ApplicationCommandOptionType.Subcommand];
function getCommandDifferencesFast(existingCommand, apiData, guildCommand) {
  for (const _ of getCommandDifferences(existingCommand, apiData, guildCommand)) {
    return true;
  }
  return false;
}
__name(getCommandDifferencesFast, "getCommandDifferencesFast");
function* getCommandDifferences(existingCommand, apiData, guildCommand) {
  if (existingCommand.type !== v10.ApplicationCommandType.ChatInput && existingCommand.type) {
    if (contextMenuTypes.includes(existingCommand.type ?? v10.ApplicationCommandType.ChatInput)) {
      const casted2 = apiData;
      if (existingCommand.name !== casted2.name) {
        yield {
          key: "name",
          original: existingCommand.name,
          expected: casted2.name
        };
      }
      if (!guildCommand && (existingCommand.dm_permission ?? true) !== (casted2.dm_permission ?? true)) {
        yield {
          key: "dmPermission",
          original: String(existingCommand.dm_permission ?? true),
          expected: String(casted2.dm_permission ?? true)
        };
      }
      if (existingCommand.default_member_permissions !== casted2.default_member_permissions) {
        yield {
          key: "defaultMemberPermissions",
          original: String(existingCommand.default_member_permissions),
          expected: String(casted2.default_member_permissions)
        };
      }
      const originalLocalizedNames2 = existingCommand.name_localizations;
      const expectedLocalizedNames2 = casted2.name_localizations;
      if (!originalLocalizedNames2 && expectedLocalizedNames2) {
        yield {
          key: "nameLocalizations",
          original: "no localized names",
          expected: "localized names"
        };
      } else if (originalLocalizedNames2 && !expectedLocalizedNames2) {
        yield {
          key: "nameLocalizations",
          original: "localized names",
          expected: "no localized names"
        };
      } else if (originalLocalizedNames2 && expectedLocalizedNames2) {
        yield* reportLocalizationMapDifferences(originalLocalizedNames2, expectedLocalizedNames2, "nameLocalizations");
      }
    }
    return;
  }
  const casted = apiData;
  if (existingCommand.name.toLowerCase() !== casted.name.toLowerCase()) {
    yield {
      key: "name",
      original: existingCommand.name,
      expected: casted.name
    };
  }
  const originalLocalizedNames = existingCommand.name_localizations;
  const expectedLocalizedNames = casted.name_localizations;
  if (!originalLocalizedNames && expectedLocalizedNames) {
    yield {
      key: "nameLocalizations",
      original: "no localized names",
      expected: "localized names"
    };
  } else if (originalLocalizedNames && !expectedLocalizedNames) {
    yield {
      key: "nameLocalizations",
      original: "localized names",
      expected: "no localized names"
    };
  } else if (originalLocalizedNames && expectedLocalizedNames) {
    yield* reportLocalizationMapDifferences(originalLocalizedNames, expectedLocalizedNames, "nameLocalizations");
  }
  if (!guildCommand && (existingCommand.dm_permission ?? true) !== (casted.dm_permission ?? true)) {
    yield {
      key: "dmPermission",
      original: String(existingCommand.dm_permission ?? true),
      expected: String(casted.dm_permission ?? true)
    };
  }
  if (existingCommand.default_member_permissions !== casted.default_member_permissions) {
    yield {
      key: "defaultMemberPermissions",
      original: String(existingCommand.default_member_permissions),
      expected: String(casted.default_member_permissions)
    };
  }
  if (existingCommand.description !== casted.description) {
    yield {
      key: "description",
      original: existingCommand.description,
      expected: casted.description
    };
  }
  const originalLocalizedDescriptions = existingCommand.description_localizations;
  const expectedLocalizedDescriptions = casted.description_localizations;
  if (!originalLocalizedDescriptions && expectedLocalizedDescriptions) {
    yield {
      key: "descriptionLocalizations",
      original: "no localized descriptions",
      expected: "localized descriptions"
    };
  } else if (originalLocalizedDescriptions && !expectedLocalizedDescriptions) {
    yield {
      key: "descriptionLocalizations",
      original: "localized descriptions",
      expected: "no localized descriptions"
    };
  } else if (originalLocalizedDescriptions && expectedLocalizedDescriptions) {
    yield* reportLocalizationMapDifferences(originalLocalizedDescriptions, expectedLocalizedDescriptions, "descriptionLocalizations");
  }
  if (!existingCommand.options?.length && casted.options?.length) {
    yield {
      key: "options",
      original: "no options present",
      expected: "options present"
    };
  } else if (existingCommand.options?.length && !casted.options?.length) {
    yield {
      key: "options",
      original: "options present",
      expected: "no options present"
    };
  } else if (casted.options?.length) {
    let index = 0;
    for (const option of casted.options) {
      const currentIndex = index++;
      const existingOption = existingCommand.options[currentIndex];
      yield* reportOptionDifferences({ currentIndex, option, existingOption });
    }
    if (index < existingCommand.options.length) {
      let option;
      while ((option = existingCommand.options[index]) !== void 0) {
        const expectedType = optionTypeToPrettyName.get(option.type) ?? `unknown (${option.type}); please contact Sapphire developers about this!`;
        yield {
          key: `existing command option at index ${index}`,
          expected: "no option present",
          original: `${expectedType} with name ${option.name}`
        };
        index++;
      }
    }
  }
}
__name(getCommandDifferences, "getCommandDifferences");
function* reportLocalizationMapDifferences(originalMap, expectedMap, mapName) {
  const originalLocalizations = new Map(Object.entries(originalMap));
  for (const [key, value] of Object.entries(expectedMap)) {
    const possiblyExistingEntry = originalLocalizations.get(key);
    originalLocalizations.delete(key);
    const wasMissingBefore = typeof possiblyExistingEntry === "undefined";
    const isResetNow = value === null;
    if (wasMissingBefore && !isResetNow) {
      yield {
        key: `${mapName}.${key}`,
        original: "no localization present",
        expected: value
      };
    } else if (!wasMissingBefore && isResetNow) {
      yield {
        key: `${mapName}.${key}`,
        original: possiblyExistingEntry,
        expected: "no localization present"
      };
    } else if (possiblyExistingEntry !== value) {
      yield {
        key: `${mapName}.${key}`,
        original: String(possiblyExistingEntry),
        expected: String(value)
      };
    }
  }
  for (const [key, value] of originalLocalizations) {
    if (value) {
      yield {
        key: `${mapName}.${key}`,
        original: value,
        expected: "no localization present"
      };
    }
  }
}
__name(reportLocalizationMapDifferences, "reportLocalizationMapDifferences");
function* reportOptionDifferences({
  option,
  existingOption,
  currentIndex,
  keyPath = /* @__PURE__ */ __name((index) => `options[${index}]`, "keyPath")
}) {
  const expectedType = optionTypeToPrettyName.get(option.type) ?? `unknown (${option.type}); please contact Sapphire developers about this!`;
  if (!existingOption) {
    yield {
      key: keyPath(currentIndex),
      expected: `${expectedType} with name ${option.name}`,
      original: "no option present"
    };
    return;
  }
  if (existingOption.type !== option.type) {
    yield {
      key: `${keyPath(currentIndex)}.type`,
      original: optionTypeToPrettyName.get(existingOption.type) ?? `unknown (${existingOption.type}); please contact Sapphire developers about this!`,
      expected: expectedType
    };
  }
  if (existingOption.name !== option.name) {
    yield {
      key: `${keyPath(currentIndex)}.name`,
      original: existingOption.name,
      expected: option.name
    };
  }
  const originalLocalizedNames = existingOption.name_localizations;
  const expectedLocalizedNames = option.name_localizations;
  if (!originalLocalizedNames && expectedLocalizedNames) {
    yield {
      key: `${keyPath(currentIndex)}.nameLocalizations`,
      original: "no localized names",
      expected: "localized names"
    };
  } else if (originalLocalizedNames && !expectedLocalizedNames) {
    yield {
      key: `${keyPath(currentIndex)}.nameLocalizations`,
      original: "localized names",
      expected: "no localized names"
    };
  } else if (originalLocalizedNames && expectedLocalizedNames) {
    yield* reportLocalizationMapDifferences(originalLocalizedNames, expectedLocalizedNames, `${keyPath(currentIndex)}.nameLocalizations`);
  }
  if (existingOption.description !== option.description) {
    yield {
      key: `${keyPath(currentIndex)}.description`,
      original: existingOption.description,
      expected: option.description
    };
  }
  const originalLocalizedDescriptions = existingOption.description_localizations;
  const expectedLocalizedDescriptions = option.description_localizations;
  if (!originalLocalizedDescriptions && expectedLocalizedDescriptions) {
    yield {
      key: `${keyPath(currentIndex)}.descriptionLocalizations`,
      original: "no localized descriptions",
      expected: "localized descriptions"
    };
  } else if (originalLocalizedDescriptions && !expectedLocalizedDescriptions) {
    yield {
      key: `${keyPath(currentIndex)}.descriptionLocalizations`,
      original: "localized descriptions",
      expected: "no localized descriptions"
    };
  } else if (originalLocalizedDescriptions && expectedLocalizedDescriptions) {
    yield* reportLocalizationMapDifferences(
      originalLocalizedDescriptions,
      expectedLocalizedDescriptions,
      `${keyPath(currentIndex)}.descriptionLocalizations`
    );
  }
  if ((existingOption.required ?? false) !== (option.required ?? false)) {
    yield {
      key: `${keyPath(currentIndex)}.required`,
      original: String(existingOption.required ?? false),
      expected: String(option.required ?? false)
    };
  }
  if (subcommandTypes.includes(existingOption.type) && subcommandTypes.includes(option.type)) {
    const castedExisting = existingOption;
    const castedExpected = option;
    if (castedExisting.type === v10.ApplicationCommandOptionType.SubcommandGroup && castedExpected.type === v10.ApplicationCommandOptionType.SubcommandGroup) {
      for (const [subcommandIndex, subcommandOption] of castedExpected.options.entries()) {
        yield* reportOptionDifferences({
          currentIndex: subcommandIndex,
          option: subcommandOption,
          existingOption: castedExisting.options?.[subcommandIndex],
          keyPath: (index) => `${keyPath(currentIndex)}.options[${index}]`
        });
      }
    } else if (castedExisting.type === v10.ApplicationCommandOptionType.Subcommand && castedExpected.type === v10.ApplicationCommandOptionType.Subcommand) {
      if (!castedExisting.options?.length && castedExpected.options?.length) {
        yield {
          key: `${keyPath(currentIndex)}.options`,
          expected: "options present",
          original: "no options present"
        };
      } else if (castedExisting.options?.length && !castedExpected.options?.length) {
        yield {
          key: `${keyPath(currentIndex)}.options`,
          expected: "no options present",
          original: "options present"
        };
      } else if (castedExpected.options?.length) {
        let processedIndex = 0;
        for (const subcommandOption of castedExpected.options) {
          const currentSubCommandOptionIndex = processedIndex++;
          const existingSubcommandOption = castedExisting.options[currentSubCommandOptionIndex];
          yield* reportOptionDifferences({
            currentIndex: currentSubCommandOptionIndex,
            option: subcommandOption,
            existingOption: existingSubcommandOption,
            keyPath: (index) => `${keyPath(currentIndex)}.options[${index}]`
          });
        }
        if (processedIndex < castedExisting.options.length) {
          let option2;
          while ((option2 = castedExisting.options[processedIndex]) !== void 0) {
            const expectedType2 = optionTypeToPrettyName.get(option2.type) ?? `unknown (${option2.type}); please contact Sapphire developers about this!`;
            yield {
              key: `existing command option at path ${keyPath(currentIndex)}.options[${processedIndex}]`,
              expected: "no option present",
              original: `${expectedType2} with name ${option2.name}`
            };
            processedIndex++;
          }
        }
      }
    }
  }
  if (hasMinMaxValueSupport(option)) {
    const existingCasted = existingOption;
    if (existingCasted.min_value === void 0 && option.min_value !== void 0) {
      yield {
        key: `${keyPath(currentIndex)}.min_value`,
        expected: "min_value present",
        original: "no min_value present"
      };
    } else if (existingCasted.min_value !== void 0 && option.min_value === void 0) {
      yield {
        key: `${keyPath(currentIndex)}.min_value`,
        expected: "no min_value present",
        original: "min_value present"
      };
    } else if (existingCasted.min_value !== option.min_value) {
      yield {
        key: `${keyPath(currentIndex)}.min_value`,
        original: String(existingCasted.min_value),
        expected: String(option.min_value)
      };
    }
    if (existingCasted.max_value === void 0 && option.max_value !== void 0) {
      yield {
        key: `${keyPath(currentIndex)}.max_value`,
        expected: "max_value present",
        original: "no max_value present"
      };
    } else if (existingCasted.max_value !== void 0 && option.max_value === void 0) {
      yield {
        key: `${keyPath(currentIndex)}.max_value`,
        expected: "no max_value present",
        original: "max_value present"
      };
    } else if (existingCasted.max_value !== option.max_value) {
      yield {
        key: `${keyPath(currentIndex)}.max_value`,
        original: String(existingCasted.max_value),
        expected: String(option.max_value)
      };
    }
  }
  if (hasChoicesAndAutocompleteSupport(option)) {
    const existingCasted = existingOption;
    if (!existingCasted.autocomplete && option.autocomplete) {
      yield {
        key: `${keyPath(currentIndex)}.autocomplete`,
        expected: "autocomplete enabled",
        original: "autocomplete disabled"
      };
    } else if (existingCasted.autocomplete && !option.autocomplete) {
      yield {
        key: `${keyPath(currentIndex)}.autocomplete`,
        expected: "autocomplete disabled",
        original: "autocomplete enabled"
      };
    }
    if (!option.autocomplete && !existingCasted.autocomplete) {
      if (!existingCasted.choices?.length && option.choices?.length) {
        yield {
          key: `${keyPath(currentIndex)}.choices`,
          expected: "choices present",
          original: "no choices present"
        };
      } else if (existingCasted.choices?.length && !option.choices?.length) {
        yield {
          key: `${keyPath(currentIndex)}.choices`,
          expected: "no choices present",
          original: "choices present"
        };
      } else if (option.choices?.length && existingCasted.choices?.length) {
        let index = 0;
        for (const choice of option.choices) {
          const currentChoiceIndex = index++;
          const existingChoice = existingCasted.choices[currentChoiceIndex];
          if (existingChoice === void 0) {
            yield {
              key: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}]`,
              original: "no choice present",
              expected: "choice present"
            };
          } else {
            if (choice.name !== existingChoice.name) {
              yield {
                key: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}].name`,
                original: existingChoice.name,
                expected: choice.name
              };
            }
            const originalLocalizedNames2 = existingChoice.name_localizations;
            const expectedLocalizedNames2 = choice.name_localizations;
            if (!originalLocalizedNames2 && expectedLocalizedNames2) {
              yield {
                key: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}].nameLocalizations`,
                original: "no localized names",
                expected: "localized names"
              };
            } else if (originalLocalizedNames2 && !expectedLocalizedNames2) {
              yield {
                key: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}].nameLocalizations`,
                original: "localized names",
                expected: "no localized names"
              };
            } else if (originalLocalizedNames2 && expectedLocalizedNames2) {
              yield* reportLocalizationMapDifferences(
                originalLocalizedNames2,
                expectedLocalizedNames2,
                `${keyPath(currentIndex)}.choices[${currentChoiceIndex}].nameLocalizations`
              );
            }
            if (choice.value !== existingChoice.value) {
              yield {
                key: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}].value`,
                original: String(existingChoice.value),
                expected: String(choice.value)
              };
            }
          }
        }
        if (index < existingCasted.choices.length) {
          let choice;
          while ((choice = existingCasted.choices[index]) !== void 0) {
            yield {
              key: `existing choice at path ${keyPath(currentIndex)}.choices[${index}]`,
              expected: "no choice present",
              original: `choice with name "${choice.name}" and value ${typeof choice.value === "number" ? choice.value : `"${choice.value}"`} present`
            };
            index++;
          }
        }
      }
    }
  }
  if (hasMinMaxLengthSupport(option)) {
    const existingCasted = existingOption;
    if (existingCasted.min_length === void 0 && option.min_length !== void 0) {
      yield {
        key: `${keyPath(currentIndex)}.min_length`,
        expected: "min_length present",
        original: "no min_length present"
      };
    } else if (existingCasted.min_length !== void 0 && option.min_length === void 0) {
      yield {
        key: `${keyPath(currentIndex)}.min_length`,
        expected: "no min_length present",
        original: "min_length present"
      };
    } else if (existingCasted.min_length !== option.min_length) {
      yield {
        key: `${keyPath(currentIndex)}.min_length`,
        original: String(existingCasted.min_length),
        expected: String(option.min_length)
      };
    }
    if (existingCasted.max_length === void 0 && option.max_length !== void 0) {
      yield {
        key: `${keyPath(currentIndex)}.max_length`,
        expected: "max_length present",
        original: "no max_length present"
      };
    } else if (existingCasted.max_length !== void 0 && option.max_length === void 0) {
      yield {
        key: `${keyPath(currentIndex)}.max_length`,
        expected: "no max_length present",
        original: "max_length present"
      };
    } else if (existingCasted.max_length !== option.max_length) {
      yield {
        key: `${keyPath(currentIndex)}.max_length`,
        original: String(existingCasted.max_length),
        expected: String(option.max_length)
      };
    }
  }
}
__name(reportOptionDifferences, "reportOptionDifferences");
function hasMinMaxValueSupport(option) {
  return [v10.ApplicationCommandOptionType.Integer, v10.ApplicationCommandOptionType.Number].includes(option.type);
}
__name(hasMinMaxValueSupport, "hasMinMaxValueSupport");
function hasChoicesAndAutocompleteSupport(option) {
  return [v10.ApplicationCommandOptionType.Integer, v10.ApplicationCommandOptionType.Number, v10.ApplicationCommandOptionType.String].includes(option.type);
}
__name(hasChoicesAndAutocompleteSupport, "hasChoicesAndAutocompleteSupport");
function hasMinMaxLengthSupport(option) {
  return option.type === v10.ApplicationCommandOptionType.String;
}
__name(hasMinMaxLengthSupport, "hasMinMaxLengthSupport");

exports.getCommandDifferences = getCommandDifferences;
exports.getCommandDifferencesFast = getCommandDifferencesFast;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=computeDifferences.js.map