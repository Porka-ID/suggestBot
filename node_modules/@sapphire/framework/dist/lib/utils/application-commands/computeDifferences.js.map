{"version":3,"sources":["../../../../src/lib/utils/application-commands/computeDifferences.ts"],"names":["casted","originalLocalizedNames","expectedLocalizedNames","option","expectedType"],"mappings":"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","sourcesContent":["import {\n\tApplicationCommandOptionType,\n\tApplicationCommandType,\n\ttype APIApplicationCommandIntegerOption,\n\ttype APIApplicationCommandNumberOption,\n\ttype APIApplicationCommandOption,\n\ttype APIApplicationCommandOptionChoice,\n\ttype APIApplicationCommandStringOption,\n\ttype APIApplicationCommandSubcommandGroupOption,\n\ttype APIApplicationCommandSubcommandOption,\n\ttype LocalizationMap,\n\ttype RESTPostAPIApplicationCommandsJSONBody,\n\ttype RESTPostAPIChatInputApplicationCommandsJSONBody,\n\ttype RESTPostAPIContextMenuApplicationCommandsJSONBody\n} from 'discord-api-types/v10';\nimport type { InternalAPICall } from './ApplicationCommandRegistry';\n\nconst optionTypeToPrettyName = new Map([\n\t[ApplicationCommandOptionType.Subcommand, 'subcommand'],\n\t[ApplicationCommandOptionType.SubcommandGroup, 'subcommand group'],\n\t[ApplicationCommandOptionType.String, 'string option'],\n\t[ApplicationCommandOptionType.Integer, 'integer option'],\n\t[ApplicationCommandOptionType.Boolean, 'boolean option'],\n\t[ApplicationCommandOptionType.User, 'user option'],\n\t[ApplicationCommandOptionType.Channel, 'channel option'],\n\t[ApplicationCommandOptionType.Role, 'role option'],\n\t[ApplicationCommandOptionType.Mentionable, 'mentionable option'],\n\t[ApplicationCommandOptionType.Number, 'number option'],\n\t[ApplicationCommandOptionType.Attachment, 'attachment option']\n]);\n\nconst contextMenuTypes = [ApplicationCommandType.Message, ApplicationCommandType.User];\nconst subcommandTypes = [ApplicationCommandOptionType.SubcommandGroup, ApplicationCommandOptionType.Subcommand];\n\ntype APIApplicationCommandSubcommandTypes = APIApplicationCommandSubcommandOption | APIApplicationCommandSubcommandGroupOption;\ntype APIApplicationCommandNumericTypes = APIApplicationCommandIntegerOption | APIApplicationCommandNumberOption;\ntype APIApplicationCommandChoosableAndAutocompletableTypes = APIApplicationCommandNumericTypes | APIApplicationCommandStringOption;\n\n/**\n * @returns `true` if there are differences, `false` otherwise\n */\nexport function getCommandDifferencesFast(\n\texistingCommand: RESTPostAPIApplicationCommandsJSONBody,\n\tapiData: InternalAPICall['builtData'],\n\tguildCommand: boolean\n) {\n\tfor (const _ of getCommandDifferences(existingCommand, apiData, guildCommand)) {\n\t\t// Return immediately on first difference found (also means we skip all other checks)\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nexport function* getCommandDifferences(\n\texistingCommand: RESTPostAPIApplicationCommandsJSONBody,\n\tapiData: InternalAPICall['builtData'],\n\tguildCommand: boolean\n): Generator<CommandDifference> {\n\tif (existingCommand.type !== ApplicationCommandType.ChatInput && existingCommand.type) {\n\t\t// Check context menus\n\t\tif (contextMenuTypes.includes(existingCommand.type ?? ApplicationCommandType.ChatInput)) {\n\t\t\tconst casted = apiData as RESTPostAPIContextMenuApplicationCommandsJSONBody;\n\n\t\t\t// Check name\n\t\t\tif (existingCommand.name !== casted.name) {\n\t\t\t\tyield {\n\t\t\t\t\tkey: 'name',\n\t\t\t\t\toriginal: existingCommand.name,\n\t\t\t\t\texpected: casted.name\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Check dmPermission only for non-guild commands\n\t\t\tif (!guildCommand && (existingCommand.dm_permission ?? true) !== (casted.dm_permission ?? true)) {\n\t\t\t\tyield {\n\t\t\t\t\tkey: 'dmPermission',\n\t\t\t\t\toriginal: String(existingCommand.dm_permission ?? true),\n\t\t\t\t\texpected: String(casted.dm_permission ?? true)\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Check defaultMemberPermissions\n\t\t\tif (existingCommand.default_member_permissions !== casted.default_member_permissions) {\n\t\t\t\tyield {\n\t\t\t\t\tkey: 'defaultMemberPermissions',\n\t\t\t\t\toriginal: String(existingCommand.default_member_permissions),\n\t\t\t\t\texpected: String(casted.default_member_permissions)\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Check localized names\n\t\t\tconst originalLocalizedNames = existingCommand.name_localizations;\n\t\t\tconst expectedLocalizedNames = casted.name_localizations;\n\n\t\t\tif (!originalLocalizedNames && expectedLocalizedNames) {\n\t\t\t\tyield {\n\t\t\t\t\tkey: 'nameLocalizations',\n\t\t\t\t\toriginal: 'no localized names',\n\t\t\t\t\texpected: 'localized names'\n\t\t\t\t};\n\t\t\t} else if (originalLocalizedNames && !expectedLocalizedNames) {\n\t\t\t\tyield {\n\t\t\t\t\tkey: 'nameLocalizations',\n\t\t\t\t\toriginal: 'localized names',\n\t\t\t\t\texpected: 'no localized names'\n\t\t\t\t};\n\t\t\t} else if (originalLocalizedNames && expectedLocalizedNames) {\n\t\t\t\tyield* reportLocalizationMapDifferences(originalLocalizedNames, expectedLocalizedNames, 'nameLocalizations');\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\n\tconst casted = apiData as RESTPostAPIChatInputApplicationCommandsJSONBody;\n\n\t// Check name\n\tif (existingCommand.name.toLowerCase() !== casted.name.toLowerCase()) {\n\t\tyield {\n\t\t\tkey: 'name',\n\t\t\toriginal: existingCommand.name,\n\t\t\texpected: casted.name\n\t\t};\n\t}\n\n\t// Check localized names\n\tconst originalLocalizedNames = existingCommand.name_localizations;\n\tconst expectedLocalizedNames = casted.name_localizations;\n\n\tif (!originalLocalizedNames && expectedLocalizedNames) {\n\t\tyield {\n\t\t\tkey: 'nameLocalizations',\n\t\t\toriginal: 'no localized names',\n\t\t\texpected: 'localized names'\n\t\t};\n\t} else if (originalLocalizedNames && !expectedLocalizedNames) {\n\t\tyield {\n\t\t\tkey: 'nameLocalizations',\n\t\t\toriginal: 'localized names',\n\t\t\texpected: 'no localized names'\n\t\t};\n\t} else if (originalLocalizedNames && expectedLocalizedNames) {\n\t\tyield* reportLocalizationMapDifferences(originalLocalizedNames, expectedLocalizedNames, 'nameLocalizations');\n\t}\n\n\t// Check dmPermission\n\tif (!guildCommand && (existingCommand.dm_permission ?? true) !== (casted.dm_permission ?? true)) {\n\t\tyield {\n\t\t\tkey: 'dmPermission',\n\t\t\toriginal: String(existingCommand.dm_permission ?? true),\n\t\t\texpected: String(casted.dm_permission ?? true)\n\t\t};\n\t}\n\n\t// Check defaultMemberPermissions\n\tif (existingCommand.default_member_permissions !== casted.default_member_permissions) {\n\t\tyield {\n\t\t\tkey: 'defaultMemberPermissions',\n\t\t\toriginal: String(existingCommand.default_member_permissions),\n\t\t\texpected: String(casted.default_member_permissions)\n\t\t};\n\t}\n\n\t// Check description\n\tif (existingCommand.description !== casted.description) {\n\t\tyield {\n\t\t\tkey: 'description',\n\t\t\toriginal: existingCommand.description,\n\t\t\texpected: casted.description\n\t\t};\n\t}\n\n\t// Check localized descriptions\n\tconst originalLocalizedDescriptions = existingCommand.description_localizations;\n\tconst expectedLocalizedDescriptions = casted.description_localizations;\n\n\tif (!originalLocalizedDescriptions && expectedLocalizedDescriptions) {\n\t\tyield {\n\t\t\tkey: 'descriptionLocalizations',\n\t\t\toriginal: 'no localized descriptions',\n\t\t\texpected: 'localized descriptions'\n\t\t};\n\t} else if (originalLocalizedDescriptions && !expectedLocalizedDescriptions) {\n\t\tyield {\n\t\t\tkey: 'descriptionLocalizations',\n\t\t\toriginal: 'localized descriptions',\n\t\t\texpected: 'no localized descriptions'\n\t\t};\n\t} else if (originalLocalizedDescriptions && expectedLocalizedDescriptions) {\n\t\tyield* reportLocalizationMapDifferences(originalLocalizedDescriptions, expectedLocalizedDescriptions, 'descriptionLocalizations');\n\t}\n\n\t// 0. No existing options and now we have options\n\tif (!existingCommand.options?.length && casted.options?.length) {\n\t\tyield {\n\t\t\tkey: 'options',\n\t\t\toriginal: 'no options present',\n\t\t\texpected: 'options present'\n\t\t};\n\t}\n\t// 1. Existing options and now we have no options\n\telse if (existingCommand.options?.length && !casted.options?.length) {\n\t\tyield {\n\t\t\tkey: 'options',\n\t\t\toriginal: 'options present',\n\t\t\texpected: 'no options present'\n\t\t};\n\t}\n\t// 2. Iterate over each option if we have any and see what's different\n\telse if (casted.options?.length) {\n\t\tlet index = 0;\n\t\tfor (const option of casted.options) {\n\t\t\tconst currentIndex = index++;\n\t\t\tconst existingOption = existingCommand.options![currentIndex];\n\t\t\tyield* reportOptionDifferences({ currentIndex, option, existingOption });\n\t\t}\n\n\t\t// If we went through less options than we previously had, report that\n\t\tif (index < existingCommand.options!.length) {\n\t\t\tlet option: APIApplicationCommandOption;\n\t\t\twhile ((option = existingCommand.options![index]) !== undefined) {\n\t\t\t\tconst expectedType =\n\t\t\t\t\toptionTypeToPrettyName.get(option.type) ?? `unknown (${option.type}); please contact Sapphire developers about this!`;\n\n\t\t\t\tyield {\n\t\t\t\t\tkey: `existing command option at index ${index}`,\n\t\t\t\t\texpected: 'no option present',\n\t\t\t\t\toriginal: `${expectedType} with name ${option.name}`\n\t\t\t\t};\n\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction* reportLocalizationMapDifferences(\n\toriginalMap: LocalizationMap,\n\texpectedMap: LocalizationMap,\n\tmapName: string\n): Generator<CommandDifference> {\n\tconst originalLocalizations = new Map(Object.entries(originalMap));\n\n\tfor (const [key, value] of Object.entries(expectedMap)) {\n\t\tconst possiblyExistingEntry = originalLocalizations.get(key) as string | undefined;\n\t\toriginalLocalizations.delete(key);\n\n\t\tconst wasMissingBefore = typeof possiblyExistingEntry === 'undefined';\n\t\tconst isResetNow = value === null;\n\n\t\t// Was missing before and now is present\n\t\tif (wasMissingBefore && !isResetNow) {\n\t\t\tyield {\n\t\t\t\tkey: `${mapName}.${key}`,\n\t\t\t\toriginal: 'no localization present',\n\t\t\t\texpected: value\n\t\t\t};\n\t\t}\n\t\t// Was present before and now is reset\n\t\telse if (!wasMissingBefore && isResetNow) {\n\t\t\tyield {\n\t\t\t\tkey: `${mapName}.${key}`,\n\t\t\t\toriginal: possiblyExistingEntry,\n\t\t\t\texpected: 'no localization present'\n\t\t\t};\n\t\t}\n\t\t// Not equal\n\t\t// eslint-disable-next-line no-negated-condition\n\t\telse if (possiblyExistingEntry !== value) {\n\t\t\tyield {\n\t\t\t\tkey: `${mapName}.${key}`,\n\t\t\t\toriginal: String(possiblyExistingEntry),\n\t\t\t\texpected: String(value)\n\t\t\t};\n\t\t}\n\t}\n\n\t// Report any remaining localizations\n\tfor (const [key, value] of originalLocalizations) {\n\t\tif (value) {\n\t\t\tyield {\n\t\t\t\tkey: `${mapName}.${key}`,\n\t\t\t\toriginal: value,\n\t\t\t\texpected: 'no localization present'\n\t\t\t};\n\t\t}\n\t}\n}\n\nexport interface CommandDifference {\n\tkey: string;\n\texpected: string;\n\toriginal: string;\n}\n\nfunction* reportOptionDifferences({\n\toption,\n\texistingOption,\n\tcurrentIndex,\n\tkeyPath = (index: number) => `options[${index}]`\n}: {\n\toption: APIApplicationCommandOption;\n\tcurrentIndex: number;\n\texistingOption?: APIApplicationCommandOption;\n\tkeyPath?: (index: number) => string;\n}): Generator<CommandDifference> {\n\tconst expectedType = optionTypeToPrettyName.get(option.type) ?? `unknown (${option.type}); please contact Sapphire developers about this!`;\n\n\t// If current option doesn't exist, report and return\n\tif (!existingOption) {\n\t\tyield {\n\t\t\tkey: keyPath(currentIndex),\n\t\t\texpected: `${expectedType} with name ${option.name}`,\n\t\t\toriginal: 'no option present'\n\t\t};\n\t\treturn;\n\t}\n\n\t// Check type\n\tif (existingOption.type !== option.type) {\n\t\tyield {\n\t\t\tkey: `${keyPath(currentIndex)}.type`,\n\t\t\toriginal:\n\t\t\t\toptionTypeToPrettyName.get(existingOption.type) ?? `unknown (${existingOption.type}); please contact Sapphire developers about this!`,\n\t\t\texpected: expectedType\n\t\t};\n\t}\n\n\t// Check name\n\tif (existingOption.name !== option.name) {\n\t\tyield {\n\t\t\tkey: `${keyPath(currentIndex)}.name`,\n\t\t\toriginal: existingOption.name,\n\t\t\texpected: option.name\n\t\t};\n\t}\n\n\t// Check localized names\n\tconst originalLocalizedNames = existingOption.name_localizations;\n\tconst expectedLocalizedNames = option.name_localizations;\n\n\tif (!originalLocalizedNames && expectedLocalizedNames) {\n\t\tyield {\n\t\t\tkey: `${keyPath(currentIndex)}.nameLocalizations`,\n\t\t\toriginal: 'no localized names',\n\t\t\texpected: 'localized names'\n\t\t};\n\t} else if (originalLocalizedNames && !expectedLocalizedNames) {\n\t\tyield {\n\t\t\tkey: `${keyPath(currentIndex)}.nameLocalizations`,\n\t\t\toriginal: 'localized names',\n\t\t\texpected: 'no localized names'\n\t\t};\n\t} else if (originalLocalizedNames && expectedLocalizedNames) {\n\t\tyield* reportLocalizationMapDifferences(originalLocalizedNames, expectedLocalizedNames, `${keyPath(currentIndex)}.nameLocalizations`);\n\t}\n\n\t// Check description\n\tif (existingOption.description !== option.description) {\n\t\tyield {\n\t\t\tkey: `${keyPath(currentIndex)}.description`,\n\t\t\toriginal: existingOption.description,\n\t\t\texpected: option.description\n\t\t};\n\t}\n\n\t// Check localized descriptions\n\tconst originalLocalizedDescriptions = existingOption.description_localizations;\n\tconst expectedLocalizedDescriptions = option.description_localizations;\n\n\tif (!originalLocalizedDescriptions && expectedLocalizedDescriptions) {\n\t\tyield {\n\t\t\tkey: `${keyPath(currentIndex)}.descriptionLocalizations`,\n\t\t\toriginal: 'no localized descriptions',\n\t\t\texpected: 'localized descriptions'\n\t\t};\n\t} else if (originalLocalizedDescriptions && !expectedLocalizedDescriptions) {\n\t\tyield {\n\t\t\tkey: `${keyPath(currentIndex)}.descriptionLocalizations`,\n\t\t\toriginal: 'localized descriptions',\n\t\t\texpected: 'no localized descriptions'\n\t\t};\n\t} else if (originalLocalizedDescriptions && expectedLocalizedDescriptions) {\n\t\tyield* reportLocalizationMapDifferences(\n\t\t\toriginalLocalizedDescriptions,\n\t\t\texpectedLocalizedDescriptions,\n\t\t\t`${keyPath(currentIndex)}.descriptionLocalizations`\n\t\t);\n\t}\n\n\t// Check required\n\tif ((existingOption.required ?? false) !== (option.required ?? false)) {\n\t\tyield {\n\t\t\tkey: `${keyPath(currentIndex)}.required`,\n\t\t\toriginal: String(existingOption.required ?? false),\n\t\t\texpected: String(option.required ?? false)\n\t\t};\n\t}\n\n\t// Check for subcommands\n\tif (subcommandTypes.includes(existingOption.type) && subcommandTypes.includes(option.type)) {\n\t\tconst castedExisting = existingOption as APIApplicationCommandSubcommandTypes;\n\t\tconst castedExpected = option as APIApplicationCommandSubcommandTypes;\n\n\t\tif (\n\t\t\tcastedExisting.type === ApplicationCommandOptionType.SubcommandGroup &&\n\t\t\tcastedExpected.type === ApplicationCommandOptionType.SubcommandGroup\n\t\t) {\n\t\t\t// We know we have options in this case, because they are both groups\n\t\t\tfor (const [subcommandIndex, subcommandOption] of castedExpected.options!.entries()) {\n\t\t\t\tyield* reportOptionDifferences({\n\t\t\t\t\tcurrentIndex: subcommandIndex,\n\t\t\t\t\toption: subcommandOption,\n\t\t\t\t\texistingOption: castedExisting.options?.[subcommandIndex],\n\t\t\t\t\tkeyPath: (index) => `${keyPath(currentIndex)}.options[${index}]`\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (\n\t\t\tcastedExisting.type === ApplicationCommandOptionType.Subcommand &&\n\t\t\tcastedExpected.type === ApplicationCommandOptionType.Subcommand\n\t\t) {\n\t\t\t// 0. No existing options and now we have options\n\t\t\tif (!castedExisting.options?.length && castedExpected.options?.length) {\n\t\t\t\tyield {\n\t\t\t\t\tkey: `${keyPath(currentIndex)}.options`,\n\t\t\t\t\texpected: 'options present',\n\t\t\t\t\toriginal: 'no options present'\n\t\t\t\t};\n\t\t\t}\n\t\t\t// 1. Existing options and now we have no options\n\t\t\telse if (castedExisting.options?.length && !castedExpected.options?.length) {\n\t\t\t\tyield {\n\t\t\t\t\tkey: `${keyPath(currentIndex)}.options`,\n\t\t\t\t\texpected: 'no options present',\n\t\t\t\t\toriginal: 'options present'\n\t\t\t\t};\n\t\t\t}\n\t\t\t// 2. Iterate over each option if we have any and see what's different\n\t\t\telse if (castedExpected.options?.length) {\n\t\t\t\tlet processedIndex = 0;\n\t\t\t\tfor (const subcommandOption of castedExpected.options) {\n\t\t\t\t\tconst currentSubCommandOptionIndex = processedIndex++;\n\t\t\t\t\tconst existingSubcommandOption = castedExisting.options![currentSubCommandOptionIndex];\n\n\t\t\t\t\tyield* reportOptionDifferences({\n\t\t\t\t\t\tcurrentIndex: currentSubCommandOptionIndex,\n\t\t\t\t\t\toption: subcommandOption,\n\t\t\t\t\t\texistingOption: existingSubcommandOption,\n\t\t\t\t\t\tkeyPath: (index) => `${keyPath(currentIndex)}.options[${index}]`\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// If we went through less options than we previously had, report that\n\t\t\t\tif (processedIndex < castedExisting.options!.length) {\n\t\t\t\t\tlet option: APIApplicationCommandOption;\n\t\t\t\t\twhile ((option = castedExisting.options![processedIndex]) !== undefined) {\n\t\t\t\t\t\tconst expectedType =\n\t\t\t\t\t\t\toptionTypeToPrettyName.get(option.type) ?? `unknown (${option.type}); please contact Sapphire developers about this!`;\n\n\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\tkey: `existing command option at path ${keyPath(currentIndex)}.options[${processedIndex}]`,\n\t\t\t\t\t\t\texpected: 'no option present',\n\t\t\t\t\t\t\toriginal: `${expectedType} with name ${option.name}`\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tprocessedIndex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hasMinMaxValueSupport(option)) {\n\t\t// Check min and max_value\n\t\tconst existingCasted = existingOption as APIApplicationCommandNumericTypes;\n\n\t\t// 0. No min_value and now we have min_value\n\t\tif (existingCasted.min_value === undefined && option.min_value !== undefined) {\n\t\t\tyield {\n\t\t\t\tkey: `${keyPath(currentIndex)}.min_value`,\n\t\t\t\texpected: 'min_value present',\n\t\t\t\toriginal: 'no min_value present'\n\t\t\t};\n\t\t}\n\t\t// 1. Have min_value and now we don't\n\t\telse if (existingCasted.min_value !== undefined && option.min_value === undefined) {\n\t\t\tyield {\n\t\t\t\tkey: `${keyPath(currentIndex)}.min_value`,\n\t\t\t\texpected: 'no min_value present',\n\t\t\t\toriginal: 'min_value present'\n\t\t\t};\n\t\t}\n\t\t// 2. Equality check\n\t\telse if (existingCasted.min_value !== option.min_value) {\n\t\t\tyield {\n\t\t\t\tkey: `${keyPath(currentIndex)}.min_value`,\n\t\t\t\toriginal: String(existingCasted.min_value),\n\t\t\t\texpected: String(option.min_value)\n\t\t\t};\n\t\t}\n\n\t\t// 0. No max_value and now we have max_value\n\t\tif (existingCasted.max_value === undefined && option.max_value !== undefined) {\n\t\t\tyield {\n\t\t\t\tkey: `${keyPath(currentIndex)}.max_value`,\n\t\t\t\texpected: 'max_value present',\n\t\t\t\toriginal: 'no max_value present'\n\t\t\t};\n\t\t}\n\t\t// 1. Have max_value and now we don't\n\t\telse if (existingCasted.max_value !== undefined && option.max_value === undefined) {\n\t\t\tyield {\n\t\t\t\tkey: `${keyPath(currentIndex)}.max_value`,\n\t\t\t\texpected: 'no max_value present',\n\t\t\t\toriginal: 'max_value present'\n\t\t\t};\n\t\t}\n\t\t// 2. Equality check\n\t\telse if (existingCasted.max_value !== option.max_value) {\n\t\t\tyield {\n\t\t\t\tkey: `${keyPath(currentIndex)}.max_value`,\n\t\t\t\toriginal: String(existingCasted.max_value),\n\t\t\t\texpected: String(option.max_value)\n\t\t\t};\n\t\t}\n\t}\n\n\tif (hasChoicesAndAutocompleteSupport(option)) {\n\t\tconst existingCasted = existingOption as APIApplicationCommandChoosableAndAutocompletableTypes;\n\n\t\t// 0. No autocomplete and now it should autocomplete\n\t\tif (!existingCasted.autocomplete && option.autocomplete) {\n\t\t\tyield {\n\t\t\t\tkey: `${keyPath(currentIndex)}.autocomplete`,\n\t\t\t\texpected: 'autocomplete enabled',\n\t\t\t\toriginal: 'autocomplete disabled'\n\t\t\t};\n\t\t}\n\t\t// 1. Have autocomplete and now it shouldn't\n\t\telse if (existingCasted.autocomplete && !option.autocomplete) {\n\t\t\tyield {\n\t\t\t\tkey: `${keyPath(currentIndex)}.autocomplete`,\n\t\t\t\texpected: 'autocomplete disabled',\n\t\t\t\toriginal: 'autocomplete enabled'\n\t\t\t};\n\t\t}\n\n\t\tif (!option.autocomplete && !existingCasted.autocomplete) {\n\t\t\t// 0. No choices and now we have choices\n\t\t\tif (!existingCasted.choices?.length && option.choices?.length) {\n\t\t\t\tyield {\n\t\t\t\t\tkey: `${keyPath(currentIndex)}.choices`,\n\t\t\t\t\texpected: 'choices present',\n\t\t\t\t\toriginal: 'no choices present'\n\t\t\t\t};\n\t\t\t}\n\t\t\t// 1. Have choices and now we don't\n\t\t\telse if (existingCasted.choices?.length && !option.choices?.length) {\n\t\t\t\tyield {\n\t\t\t\t\tkey: `${keyPath(currentIndex)}.choices`,\n\t\t\t\t\texpected: 'no choices present',\n\t\t\t\t\toriginal: 'choices present'\n\t\t\t\t};\n\t\t\t}\n\t\t\t// 2. Check every choice to see differences\n\t\t\telse if (option.choices?.length && existingCasted.choices?.length) {\n\t\t\t\tlet index = 0;\n\t\t\t\tfor (const choice of option.choices) {\n\t\t\t\t\tconst currentChoiceIndex = index++;\n\t\t\t\t\tconst existingChoice = existingCasted.choices[currentChoiceIndex];\n\n\t\t\t\t\t// If this choice never existed, return the difference\n\t\t\t\t\tif (existingChoice === undefined) {\n\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\tkey: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}]`,\n\t\t\t\t\t\t\toriginal: 'no choice present',\n\t\t\t\t\t\t\texpected: 'choice present'\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (choice.name !== existingChoice.name) {\n\t\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\t\tkey: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}].name`,\n\t\t\t\t\t\t\t\toriginal: existingChoice.name,\n\t\t\t\t\t\t\t\texpected: choice.name\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check localized names\n\t\t\t\t\t\tconst originalLocalizedNames = existingChoice.name_localizations;\n\t\t\t\t\t\tconst expectedLocalizedNames = choice.name_localizations;\n\n\t\t\t\t\t\tif (!originalLocalizedNames && expectedLocalizedNames) {\n\t\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\t\tkey: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}].nameLocalizations`,\n\t\t\t\t\t\t\t\toriginal: 'no localized names',\n\t\t\t\t\t\t\t\texpected: 'localized names'\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else if (originalLocalizedNames && !expectedLocalizedNames) {\n\t\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\t\tkey: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}].nameLocalizations`,\n\t\t\t\t\t\t\t\toriginal: 'localized names',\n\t\t\t\t\t\t\t\texpected: 'no localized names'\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else if (originalLocalizedNames && expectedLocalizedNames) {\n\t\t\t\t\t\t\tyield* reportLocalizationMapDifferences(\n\t\t\t\t\t\t\t\toriginalLocalizedNames,\n\t\t\t\t\t\t\t\texpectedLocalizedNames,\n\t\t\t\t\t\t\t\t`${keyPath(currentIndex)}.choices[${currentChoiceIndex}].nameLocalizations`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (choice.value !== existingChoice.value) {\n\t\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\t\tkey: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}].value`,\n\t\t\t\t\t\t\t\toriginal: String(existingChoice.value),\n\t\t\t\t\t\t\t\texpected: String(choice.value)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If there are more choices than the expected ones, return the difference\n\t\t\t\tif (index < existingCasted.choices.length) {\n\t\t\t\t\tlet choice: APIApplicationCommandOptionChoice;\n\t\t\t\t\twhile ((choice = existingCasted.choices[index]) !== undefined) {\n\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\tkey: `existing choice at path ${keyPath(currentIndex)}.choices[${index}]`,\n\t\t\t\t\t\t\texpected: 'no choice present',\n\t\t\t\t\t\t\toriginal: `choice with name \"${choice.name}\" and value ${\n\t\t\t\t\t\t\t\ttypeof choice.value === 'number' ? choice.value : `\"${choice.value}\"`\n\t\t\t\t\t\t\t} present`\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hasMinMaxLengthSupport(option)) {\n\t\t// Check min and max_value\n\t\tconst existingCasted = existingOption as APIApplicationCommandStringOption;\n\n\t\t// 0. No min_length and now we have min_length\n\t\tif (existingCasted.min_length === undefined && option.min_length !== undefined) {\n\t\t\tyield {\n\t\t\t\tkey: `${keyPath(currentIndex)}.min_length`,\n\t\t\t\texpected: 'min_length present',\n\t\t\t\toriginal: 'no min_length present'\n\t\t\t};\n\t\t}\n\t\t// 1. Have min_length and now we don't\n\t\telse if (existingCasted.min_length !== undefined && option.min_length === undefined) {\n\t\t\tyield {\n\t\t\t\tkey: `${keyPath(currentIndex)}.min_length`,\n\t\t\t\texpected: 'no min_length present',\n\t\t\t\toriginal: 'min_length present'\n\t\t\t};\n\t\t}\n\t\t// 2. Equality check\n\t\telse if (existingCasted.min_length !== option.min_length) {\n\t\t\tyield {\n\t\t\t\tkey: `${keyPath(currentIndex)}.min_length`,\n\t\t\t\toriginal: String(existingCasted.min_length),\n\t\t\t\texpected: String(option.min_length)\n\t\t\t};\n\t\t}\n\n\t\t// 0. No max_length and now we have max_length\n\t\tif (existingCasted.max_length === undefined && option.max_length !== undefined) {\n\t\t\tyield {\n\t\t\t\tkey: `${keyPath(currentIndex)}.max_length`,\n\t\t\t\texpected: 'max_length present',\n\t\t\t\toriginal: 'no max_length present'\n\t\t\t};\n\t\t}\n\t\t// 1. Have max_length and now we don't\n\t\telse if (existingCasted.max_length !== undefined && option.max_length === undefined) {\n\t\t\tyield {\n\t\t\t\tkey: `${keyPath(currentIndex)}.max_length`,\n\t\t\t\texpected: 'no max_length present',\n\t\t\t\toriginal: 'max_length present'\n\t\t\t};\n\t\t}\n\t\t// 2. Equality check\n\t\telse if (existingCasted.max_length !== option.max_length) {\n\t\t\tyield {\n\t\t\t\tkey: `${keyPath(currentIndex)}.max_length`,\n\t\t\t\toriginal: String(existingCasted.max_length),\n\t\t\t\texpected: String(option.max_length)\n\t\t\t};\n\t\t}\n\t}\n}\n\nfunction hasMinMaxValueSupport(option: APIApplicationCommandOption): option is APIApplicationCommandNumericTypes {\n\treturn [ApplicationCommandOptionType.Integer, ApplicationCommandOptionType.Number].includes(option.type);\n}\n\nfunction hasChoicesAndAutocompleteSupport(option: APIApplicationCommandOption): option is APIApplicationCommandChoosableAndAutocompletableTypes {\n\treturn [ApplicationCommandOptionType.Integer, ApplicationCommandOptionType.Number, ApplicationCommandOptionType.String].includes(option.type);\n}\n\nfunction hasMinMaxLengthSupport(option: APIApplicationCommandOption): option is APIApplicationCommandStringOption {\n\treturn option.type === ApplicationCommandOptionType.String;\n}\n"]}