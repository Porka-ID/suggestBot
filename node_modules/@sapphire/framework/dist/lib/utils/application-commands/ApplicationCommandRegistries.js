'use strict';

var pieces = require('@sapphire/pieces');
var Enums_js = require('../../types/Enums.js');
var Events_js = require('../../types/Events.js');
var ApplicationCommandRegistry_js = require('./ApplicationCommandRegistry.js');
var getNeededParameters_js = require('./getNeededParameters.js');
var registriesErrors_js = require('./registriesErrors.js');
var registriesLog_js = require('./registriesLog.js');

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
exports.defaultBehaviorWhenNotIdentical = Enums_js.RegisterBehavior.Overwrite;
exports.defaultGuildIds = void 0;
var registries = /* @__PURE__ */ new Map();
var allGuildIdsToFetchCommandsFor = /* @__PURE__ */ new Set();
function acquire(commandName) {
  const existing = registries.get(commandName);
  if (existing) {
    return existing;
  }
  const newRegistry = new ApplicationCommandRegistry_js.ApplicationCommandRegistry(commandName);
  registries.set(commandName, newRegistry);
  return newRegistry;
}
__name(acquire, "acquire");
function setDefaultBehaviorWhenNotIdentical(behavior) {
  exports.defaultBehaviorWhenNotIdentical = behavior ?? Enums_js.RegisterBehavior.Overwrite;
}
__name(setDefaultBehaviorWhenNotIdentical, "setDefaultBehaviorWhenNotIdentical");
function getDefaultBehaviorWhenNotIdentical() {
  return exports.defaultBehaviorWhenNotIdentical;
}
__name(getDefaultBehaviorWhenNotIdentical, "getDefaultBehaviorWhenNotIdentical");
function setDefaultGuildIds(guildIds) {
  exports.defaultGuildIds = guildIds ?? void 0;
}
__name(setDefaultGuildIds, "setDefaultGuildIds");
function getDefaultGuildIds() {
  return exports.defaultGuildIds;
}
__name(getDefaultGuildIds, "getDefaultGuildIds");
async function handleRegistryAPICalls() {
  pieces.container.client.emit(Events_js.Events.ApplicationCommandRegistriesInitialising);
  const commandStore = pieces.container.stores.get("commands");
  for (const command of commandStore.values()) {
    if (command.registerApplicationCommands) {
      try {
        await command.registerApplicationCommands(command.applicationCommandRegistry);
      } catch (error) {
        registriesErrors_js.emitPerRegistryError(error, command);
      }
    }
  }
  if (getDefaultBehaviorWhenNotIdentical() === Enums_js.RegisterBehavior.BulkOverwrite) {
    await handleBulkOverwrite(commandStore, pieces.container.client.application.commands);
    return;
  }
  const params = await getNeededParameters_js.getNeededRegistryParameters(allGuildIdsToFetchCommandsFor);
  await handleAppendOrUpdate(commandStore, params);
}
__name(handleRegistryAPICalls, "handleRegistryAPICalls");
async function handleBulkOverwrite(commandStore, applicationCommands) {
  const now = Date.now();
  const foundGlobalCommands = [];
  const foundGuildCommands = {};
  for (const command of commandStore.values()) {
    const registry = command.applicationCommandRegistry;
    for (const call of registry["apiCalls"]) {
      if (call.registerOptions.guildIds?.length) {
        for (const guildId of call.registerOptions.guildIds) {
          foundGuildCommands[guildId] ?? (foundGuildCommands[guildId] = []);
          foundGuildCommands[guildId].push({ piece: command, data: call.builtData });
        }
        continue;
      }
      foundGlobalCommands.push({ piece: command, data: call.builtData });
    }
  }
  try {
    registriesLog_js.bulkOverwriteDebug(`Overwriting global application commands, now at ${foundGlobalCommands.length} commands`);
    const result = await applicationCommands.set(foundGlobalCommands.map((x) => x.data));
    for (const [id, globalCommand] of result.entries()) {
      const piece = foundGlobalCommands.find((x) => x.data.name === globalCommand.name)?.piece;
      if (piece) {
        const registry = piece.applicationCommandRegistry;
        registry.globalCommandId = id;
        registry.addChatInputCommandIds(id);
        commandStore.aliases.set(id, piece);
      } else {
        registriesLog_js.bulkOverwriteWarn(
          `Registered global command "${globalCommand.name}" (${id}) but failed to find the piece in the command store. This should not happen`
        );
      }
    }
    registriesLog_js.bulkOverwriteInfo(`Successfully overwrote global application commands. The application now has ${result.size} global commands`);
  } catch (error) {
    registriesErrors_js.emitBulkOverwriteError(error, null);
  }
  for (const [guildId, guildCommands] of Object.entries(foundGuildCommands)) {
    try {
      registriesLog_js.bulkOverwriteDebug(`Overwriting guild application commands for guild ${guildId}, now at ${guildCommands.length} commands`);
      const result = await applicationCommands.set(
        guildCommands.map((x) => x.data),
        guildId
      );
      for (const [id, guildCommand] of result.entries()) {
        const piece = guildCommands.find((x) => x.data.name === guildCommand.name)?.piece;
        if (piece) {
          const registry = piece.applicationCommandRegistry;
          registry.guildCommandIds.set(guildId, id);
          registry.addChatInputCommandIds(id);
          commandStore.aliases.set(id, piece);
        } else {
          registriesLog_js.bulkOverwriteWarn(
            `Registered guild command "${guildCommand.name}" (${id}) but failed to find the piece in the command store. This should not happen`
          );
        }
      }
      registriesLog_js.bulkOverwriteInfo(
        `Successfully overwrote guild application commands for guild ${guildId}. The application now has ${result.size} guild commands for guild ${guildId}`
      );
    } catch (error) {
      registriesErrors_js.emitBulkOverwriteError(error, guildId);
    }
  }
  pieces.container.client.emit(Events_js.Events.ApplicationCommandRegistriesRegistered, registries, Date.now() - now);
}
__name(handleBulkOverwrite, "handleBulkOverwrite");
async function handleAppendOrUpdate(commandStore, { applicationCommands, globalCommands, guildCommands }) {
  const now = Date.now();
  for (const registry of registries.values()) {
    await registry["runAPICalls"](applicationCommands, globalCommands, guildCommands);
    const piece = registry.command;
    if (piece) {
      for (const nameOrId of piece.applicationCommandRegistry.chatInputCommands) {
        commandStore.aliases.set(nameOrId, piece);
      }
      for (const nameOrId of piece.applicationCommandRegistry.contextMenuCommands) {
        commandStore.aliases.set(nameOrId, piece);
      }
    }
  }
  pieces.container.client.emit(Events_js.Events.ApplicationCommandRegistriesRegistered, registries, Date.now() - now);
}
__name(handleAppendOrUpdate, "handleAppendOrUpdate");

exports.acquire = acquire;
exports.allGuildIdsToFetchCommandsFor = allGuildIdsToFetchCommandsFor;
exports.getDefaultBehaviorWhenNotIdentical = getDefaultBehaviorWhenNotIdentical;
exports.getDefaultGuildIds = getDefaultGuildIds;
exports.handleBulkOverwrite = handleBulkOverwrite;
exports.handleRegistryAPICalls = handleRegistryAPICalls;
exports.registries = registries;
exports.setDefaultBehaviorWhenNotIdentical = setDefaultBehaviorWhenNotIdentical;
exports.setDefaultGuildIds = setDefaultGuildIds;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=ApplicationCommandRegistries.js.map