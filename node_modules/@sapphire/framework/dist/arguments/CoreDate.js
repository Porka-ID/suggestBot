'use strict';

var pieces = require('@sapphire/pieces');
var Identifiers_js = require('../lib/errors/Identifiers.js');
var date_js = require('../lib/resolvers/date.js');
var Argument_js = require('../lib/structures/Argument.js');

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var _CoreArgument = class _CoreArgument extends Argument_js.Argument {
  constructor(context) {
    super(context, { name: "date" });
    this.messages = {
      [Identifiers_js.Identifiers.ArgumentDateTooEarly]: ({ minimum }) => `The given date must be after ${new Date(minimum).toISOString()}.`,
      [Identifiers_js.Identifiers.ArgumentDateTooFar]: ({ maximum }) => `The given date must be before ${new Date(maximum).toISOString()}.`,
      [Identifiers_js.Identifiers.ArgumentDateError]: () => "The argument did not resolve to a date."
    };
  }
  run(parameter, context) {
    const resolved = date_js.resolveDate(parameter, { minimum: context.minimum, maximum: context.maximum });
    return resolved.mapErrInto(
      (identifier) => this.error({
        parameter,
        identifier,
        message: this.messages[identifier](context),
        context
      })
    );
  }
};
__name(_CoreArgument, "CoreArgument");
var CoreArgument = _CoreArgument;
void pieces.container.stores.loadPiece({
  name: "date",
  piece: CoreArgument,
  store: "arguments"
});

exports.CoreArgument = CoreArgument;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=CoreDate.js.map