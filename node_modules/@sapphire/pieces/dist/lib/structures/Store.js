"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Store_calledLoadAll, _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Store = void 0;
const collection_1 = require("@discordjs/collection");
const utilities_1 = require("@sapphire/utilities");
const fs_1 = require("fs");
const path_1 = require("path");
const LoaderError_1 = require("../errors/LoaderError");
const Path_1 = require("../internal/Path");
const constants_1 = require("../internal/constants");
const Container_1 = require("../shared/Container");
const LoaderStrategy_1 = require("../strategies/LoaderStrategy");
const StoreRegistry_1 = require("./StoreRegistry");
/**
 * The store class which contains {@link Piece}s.
 */
class Store extends collection_1.Collection {
    /**
     * @param constructor The piece constructor this store loads.
     * @param options The options for the store.
     */
    constructor(constructor, options) {
        super();
        Object.defineProperty(this, "Constructor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "paths", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "strategy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The queue of manually registered pieces to load.
         */
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        /**
         * Whether or not the store has called `loadAll` at least once.
         */
        _Store_calledLoadAll.set(this, false);
        this.Constructor = constructor;
        this.name = options.name;
        this.paths = new Set(options.paths ?? []);
        this.strategy = options.strategy ?? Store.defaultStrategy;
    }
    /**
     * A reference to the {@link Container} object for ease of use.
     * @see container
     */
    get container() {
        return Container_1.container;
    }
    /**
     * Registers a directory into the store.
     * @param path The path to be added.
     * @example
     * ```typescript
     * store
     *   .registerPath(resolve('commands'))
     *   .registerPath(resolve('third-party', 'commands'));
     * ```
     */
    registerPath(path) {
        const root = (0, Path_1.resolvePath)(path);
        this.paths.add(root);
        Store.logger?.(`[STORE => ${this.name}] [REGISTER] Registered path '${root}'.`);
        return this;
    }
    /**
     * Adds a piece into the store's list of manually registered pieces. If {@linkcode Store.loadAll()} was called, the
     * piece will be loaded immediately, otherwise it will be queued until {@linkcode Store.loadAll()} is called.
     *
     * All manually registered pieces will be kept even after they are loaded to ensure they can be loaded again if
     * {@linkcode Store.loadAll()} is called again.
     *
     * @remarks
     *
     * - Pieces loaded this way will have their {@linkcode Piece.Context.root root} and
     *   {@linkcode Piece.Context.path path} set to {@linkcode VirtualPath}, and as such, cannot be reloaded.
     * - This method is useful in environments where file system access is limited or unavailable, such as when using
     *   {@link https://en.wikipedia.org/wiki/Serverless_computing Serverless Computing}.
     * - This method will always throw a {@link TypeError} if `entry.piece` is not a class.
     * - This method will always throw a {@linkcode LoaderError} if the piece does not extend the
     *   {@linkcode Store#Constructor store's piece constructor}.
     * - This operation is atomic, if any of the above errors are thrown, the piece will not be loaded.
     *
     * @seealso {@linkcode StoreRegistry.loadPiece()}
     * @since 3.8.0
     * @param entry The entry to load.
     * @example
     * ```typescript
     * import { container } from '@sapphire/pieces';
     *
     * class PingCommand extends Command {
     *   // ...
     * }
     *
     * container.stores.get('commands').loadPiece({
     *   name: 'ping',
     *   piece: PingCommand
     * });
     * ```
     */
    async loadPiece(entry) {
        if (!(0, utilities_1.isClass)(entry.piece)) {
            throw new TypeError(`The piece ${entry.name} is not a Class. ${String(entry.piece)}`);
        }
        // If the piece does not extend the store's Piece class, throw an error:
        if (!(0, utilities_1.classExtends)(entry.piece, this.Constructor)) {
            throw new LoaderError_1.LoaderError(LoaderError_1.LoaderErrorType.IncorrectType, `The piece ${entry.name} does not extend ${this.name}`);
        }
        this[constants_1.ManuallyRegisteredPiecesSymbol].push(entry);
        if (__classPrivateFieldGet(this, _Store_calledLoadAll, "f")) {
            const piece = this.construct(entry.piece, {
                name: entry.name,
                root: constants_1.VirtualPath,
                path: constants_1.VirtualPath,
                extension: constants_1.VirtualPath
            });
            await this.insert(piece);
        }
    }
    /**
     * Loads one or more pieces from a path.
     * @param root The root directory the file is from.
     * @param path The path of the file to load, relative to the `root`.
     * @return All the loaded pieces.
     */
    async load(root, path) {
        if (root === constants_1.VirtualPath) {
            throw new LoaderError_1.LoaderError(LoaderError_1.LoaderErrorType.VirtualPiece, `Cannot load a virtual file.`);
        }
        const full = (0, path_1.join)(root, path);
        const data = this.strategy.filter(full);
        if (data === null) {
            Store.logger?.(`[STORE => ${this.name}] [LOAD] Skipped piece '${full}' as 'LoaderStrategy#filter' returned 'null'.`);
            return [];
        }
        const promises = [];
        const finishedData = this.hydrateModuleData(root, data);
        for await (const Ctor of this.strategy.load(this, finishedData)) {
            promises.push(this.insert(this.construct(Ctor, finishedData)));
        }
        return Promise.all(promises);
    }
    /**
     * Unloads a piece given its instance or its name.
     * @param name The name of the file to load.
     * @return Returns the piece that was unloaded.
     */
    async unload(name) {
        const piece = this.resolve(name);
        // Unload piece:
        this.strategy.onUnload(this, piece);
        await piece.onUnload();
        Store.logger?.(`[STORE => ${this.name}] [UNLOAD] Unloaded piece '${piece.name}'.`);
        // Remove from cache and return it:
        this.delete(piece.name);
        Store.logger?.(`[STORE => ${this.name}] [UNLOAD] Removed piece '${piece.name}'.`);
        return piece;
    }
    /**
     * Unloads all pieces from the store.
     */
    async unloadAll() {
        const promises = [];
        for (const piece of this.values()) {
            promises.push(this.unload(piece));
        }
        const results = await Promise.all(promises);
        this.strategy.onUnloadAll(this);
        Store.logger?.(`[STORE => ${this.name}] [UNLOAD-ALL] Removed all pieces.`);
        return results;
    }
    /**
     * Loads all pieces from all directories specified by {@link paths}.
     */
    async loadAll() {
        __classPrivateFieldSet(this, _Store_calledLoadAll, true, "f");
        const pieces = [];
        for (const entry of this[constants_1.ManuallyRegisteredPiecesSymbol]) {
            const piece = this.construct(entry.piece, {
                name: entry.name,
                root: constants_1.VirtualPath,
                path: constants_1.VirtualPath,
                extension: constants_1.VirtualPath
            });
            pieces.push(piece);
        }
        for (const path of this.paths) {
            for await (const piece of this.loadPath(path)) {
                pieces.push(piece);
            }
        }
        Store.logger?.(`[STORE => ${this.name}] [LOAD-ALL] Found '${pieces.length}' pieces.`);
        // Clear the store before inserting the new pieces:
        await this.unloadAll();
        Store.logger?.(`[STORE => ${this.name}] [LOAD-ALL] Cleared all pieces.`);
        // Load each piece:
        for (const piece of pieces) {
            await this.insert(piece);
        }
        // Call onLoadAll:
        this.strategy.onLoadAll(this);
        Store.logger?.(`[STORE => ${this.name}] [LOAD-ALL] Successfully loaded '${this.size}' pieces.`);
    }
    /**
     * Resolves a piece by its name or its instance.
     * @param name The name of the piece or the instance itself.
     * @return The resolved piece.
     */
    resolve(name) {
        if (typeof name === 'string') {
            const result = this.get(name);
            if (typeof result === 'undefined')
                throw new LoaderError_1.LoaderError(LoaderError_1.LoaderErrorType.UnloadedPiece, `The piece '${name}' does not exist.`);
            return result;
        }
        if (name instanceof this.Constructor)
            return name;
        throw new LoaderError_1.LoaderError(LoaderError_1.LoaderErrorType.IncorrectType, `The piece '${name.name}' is not an instance of '${this.Constructor.name}'.`);
    }
    /**
     * Inserts a piece into the store.
     * @param piece The piece to be inserted into the store.
     * @return The inserted piece.
     */
    async insert(piece) {
        if (!piece.enabled)
            return piece;
        // Load piece:
        this.strategy.onLoad(this, piece);
        await piece.onLoad();
        Store.logger?.(`[STORE => ${this.name}] [INSERT] Loaded new piece '${piece.name}'.`);
        // If the onLoad disabled the piece, call unload and return it:
        if (!piece.enabled) {
            // Unload piece:
            this.strategy.onUnload(this, piece);
            await piece.onUnload();
            Store.logger?.(`[STORE => ${this.name}] [INSERT] Unloaded new piece '${piece.name}' due to 'enabled' being 'false'.`);
            return piece;
        }
        // Unload existing piece, if any:
        const previous = super.get(piece.name);
        if (previous) {
            await this.unload(previous);
            Store.logger?.(`[STORE => ${this.name}] [INSERT] Unloaded existing piece '${piece.name}' due to conflicting 'name'.`);
        }
        // Set the new piece and return it:
        this.set(piece.name, piece);
        Store.logger?.(`[STORE => ${this.name}] [INSERT] Inserted new piece '${piece.name}'.`);
        return piece;
    }
    /**
     * Constructs a {@link Piece} instance.
     * @param Ctor The {@link Piece}'s constructor used to build the instance.
     * @param data The module's information
     * @return An instance of the constructed piece.
     */
    construct(Ctor, data) {
        return new Ctor({ store: this, root: data.root, path: data.path, name: data.name }, { name: data.name, enabled: true });
    }
    /**
     * Adds the final module data properties.
     * @param root The root directory to add.
     * @param data The module data returned from {@link ILoaderStrategy.filter}.
     * @returns The finished module data.
     */
    hydrateModuleData(root, data) {
        return { root, ...data };
    }
    /**
     * Loads a directory into the store.
     * @param root The directory to load the pieces from.
     * @return An async iterator that yields the pieces to be loaded into the store.
     */
    async *loadPath(root) {
        Store.logger?.(`[STORE => ${this.name}] [WALK] Loading all pieces from '${root}'.`);
        for await (const child of this.walk(root)) {
            const data = this.strategy.filter(child);
            if (data === null) {
                Store.logger?.(`[STORE => ${this.name}] [LOAD] Skipped piece '${child}' as 'LoaderStrategy#filter' returned 'null'.`);
                continue;
            }
            try {
                const finishedData = this.hydrateModuleData(root, data);
                for await (const Ctor of this.strategy.load(this, finishedData)) {
                    yield this.construct(Ctor, finishedData);
                }
            }
            catch (error) {
                this.strategy.onError(error, data.path);
            }
        }
    }
    /**
     * Retrieves all possible pieces.
     * @param path The directory to load the pieces from.
     * @return An async iterator that yields the modules to be processed and loaded into the store.
     */
    async *walk(path) {
        Store.logger?.(`[STORE => ${this.name}] [WALK] Loading all pieces from '${path}'.`);
        try {
            const dir = await fs_1.promises.opendir(path);
            for await (const item of dir) {
                if (item.isFile())
                    yield (0, path_1.join)(dir.path, item.name);
                else if (item.isDirectory())
                    yield* this.walk((0, path_1.join)(dir.path, item.name));
            }
        }
        catch (error) {
            // Specifically ignore ENOENT, which is commonly raised by fs operations
            // to indicate that a component of the specified pathname does not exist.
            // No entity (file or directory) could be found by the given path.
            if (error.code !== 'ENOENT')
                this.strategy.onError(error, path);
        }
    }
}
exports.Store = Store;
_Store_calledLoadAll = new WeakMap(), _a = constants_1.ManuallyRegisteredPiecesSymbol;
/**
 * The default strategy, defaults to {@link LoaderStrategy}, which is constructed on demand when a store is constructed,
 * when none was set beforehand.
 */
Object.defineProperty(Store, "defaultStrategy", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: new LoaderStrategy_1.LoaderStrategy()
});
/**
 * The default logger, defaults to `null`.
 */
Object.defineProperty(Store, "logger", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: null
});
(function (Store) {
    Store.Registry = StoreRegistry_1.StoreRegistry;
})(Store || (exports.Store = Store = {}));
//# sourceMappingURL=Store.js.map