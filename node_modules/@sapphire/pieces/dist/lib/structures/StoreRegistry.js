"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _StoreRegistry_pendingManuallyRegisteredPieces;
Object.defineProperty(exports, "__esModule", { value: true });
exports.StoreRegistry = void 0;
const collection_1 = require("@discordjs/collection");
const utilities_1 = require("@sapphire/utilities");
const path_1 = require("path");
const Path_1 = require("../internal/Path");
const RootScan_1 = require("../internal/RootScan");
const constants_1 = require("../internal/constants");
/**
 * A strict-typed store registry. This is available in {@link container}.
 * @since 2.1.0
 * @example
 * ```typescript
 * // Adding new stores
 *
 * // Register the store:
 * container.stores.register(new RouteStore());
 *
 * // Augment Sapphire to add the new store, in case of a JavaScript
 * // project, this can be moved to an `Augments.d.ts` (or any other name)
 * // file somewhere:
 * declare module '@sapphire/pieces' {
 *   export interface StoreRegistryEntries {
 *     routes: RouteStore;
 *   }
 * }
 * ```
 */
class StoreRegistry extends collection_1.Collection {
    constructor() {
        super(...arguments);
        /**
         * The queue of pieces to load.
         */
        _StoreRegistry_pendingManuallyRegisteredPieces.set(this, new collection_1.Collection());
    }
    /**
     * Loads all the registered stores.
     * @since 2.1.0
     */
    async load() {
        const promises = [];
        for (const store of this.values()) {
            promises.push(store.loadAll());
        }
        await Promise.all(promises);
    }
    /**
     * Registers all user directories from the process working directory, the default value is obtained by assuming
     * CommonJS (high accuracy) but with fallback for ECMAScript Modules (reads package.json's `main` entry, fallbacks
     * to `process.cwd()`).
     *
     * By default, if you have this folder structure:
     * ```
     * /home/me/my-bot
     * ├─ src
     * │  ├─ commands
     * │  ├─ events
     * │  └─ main.js
     * └─ package.json
     * ```
     *
     * And you run `node src/main.js`, the directories `/home/me/my-bot/src/commands` and `/home/me/my-bot/src/events` will
     * be registered for the commands and events stores respectively, since both directories are located in the same
     * directory as your main file.
     *
     * **Note**: this also registers directories for all other stores, even if they don't have a folder, this allows you
     * to create new pieces and hot-load them later anytime.
     * @since 2.1.0
     * @param rootDirectory The root directory to register pieces at.
     */
    registerPath(rootDirectory = (0, RootScan_1.getRootData)().root) {
        const root = (0, Path_1.resolvePath)(rootDirectory);
        for (const store of this.values()) {
            store.registerPath((0, path_1.join)(root, store.name));
        }
    }
    /**
     * Registers a store.
     *
     * @remarks
     *
     * - This method will allow {@linkcode StoreRegistry} to manage the store, meaning:
     *   - {@linkcode StoreRegistry.registerPath()} will call the store's
     *     {@linkcode Store.registerPath() registerPath()} method on call.
     *   - {@linkcode StoreRegistry.load()} will call the store's {@linkcode Store.load() load()} method on call.
     *   - {@linkcode StoreRegistry.loadPiece()} will call the store's {@linkcode Store.loadPiece() loadPiece()} method
     *     on call.
     * - This will also add all the manually registered pieces by {@linkcode StoreRegistry.loadPiece()} in the store.
     *
     * It is generally recommended to register a store as early as possible, before any of the aforementioned methods
     * are called, otherwise you will have to manually call the aforementioned methods for the store to work properly.
     *
     * If there were manually registered pieces for this store with {@linkcode StoreRegistry.loadPiece()}, this method
     * will add them to the store and delete the queue. Note, however, that this method will not call the store's
     * {@linkcode Store.loadPiece() loadPiece()} method, and as such, the pieces will not be loaded until
     * {@linkcode Store.loadAll()} is called.
     *
     * @since 2.1.0
     * @param store The store to register.
     */
    register(store) {
        this.set(store.name, store);
        // If there was a queue for this store, add it to the store and delete the queue:
        const queue = __classPrivateFieldGet(this, _StoreRegistry_pendingManuallyRegisteredPieces, "f").get(store.name);
        if (queue) {
            store[constants_1.ManuallyRegisteredPiecesSymbol].push(...queue);
            __classPrivateFieldGet(this, _StoreRegistry_pendingManuallyRegisteredPieces, "f").delete(store.name);
        }
        return this;
    }
    /**
     * Deregisters a store.
     * @since 2.1.0
     * @param store The store to deregister.
     */
    deregister(store) {
        this.delete(store.name);
        return this;
    }
    /**
     * If the store was {@link StoreRegistry.register registered}, this method will call the store's
     * {@linkcode Store.loadPiece() loadPiece()} method.
     *
     * If it was called, the entry will be loaded immediately without queueing.
     *
     * @remarks
     *
     * - Pieces loaded this way will have their {@linkcode Piece.Context.root root} and
     *   {@linkcode Piece.Context.path path} set to {@linkcode VirtualPath}, and as such, cannot be reloaded.
     * - This method is useful in environments where file system access is limited or unavailable, such as when using
     *   {@link https://en.wikipedia.org/wiki/Serverless_computing Serverless Computing}.
     * - This method will not throw an error if a store with the given name does not exist, it will simply be queued
     *   until it's registered.
     * - This method will always throw a {@link TypeError} if `entry.piece` is not a class.
     * - If the store is registered, this method will always throw a {@linkcode LoaderError} if the piece does not
     *   extend the registered {@linkcode Store.Constructor store's piece constructor}.
     * - This operation is atomic, if any of the above errors are thrown, the piece will not be loaded.
     *
     * @seealso {@linkcode Store.loadPiece()}
     * @since 3.8.0
     * @param entry The entry to load.
     * @example
     * ```typescript
     * import { container } from '@sapphire/pieces';
     *
     * class PingCommand extends Command {
     *   // ...
     * }
     *
     * container.stores.loadPiece({
     *   store: 'commands',
     *   name: 'ping',
     *   piece: PingCommand
     * });
     * ```
     */
    async loadPiece(entry) {
        const store = this.get(entry.store);
        if (store) {
            await store.loadPiece(entry);
        }
        else {
            if (!(0, utilities_1.isClass)(entry.piece)) {
                throw new TypeError(`The piece ${entry.name} is not a Class. ${String(entry.piece)}`);
            }
            __classPrivateFieldGet(this, _StoreRegistry_pendingManuallyRegisteredPieces, "f").ensure(entry.store, () => []).push({ name: entry.name, piece: entry.piece });
        }
    }
}
exports.StoreRegistry = StoreRegistry;
_StoreRegistry_pendingManuallyRegisteredPieces = new WeakMap();
//# sourceMappingURL=StoreRegistry.js.map